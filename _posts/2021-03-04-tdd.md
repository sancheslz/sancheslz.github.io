---
layout: post
date:  2021-03-04 00:00:00 -0300
title:  "TDD"
slug: tdd
tag: tutorial
category: "Testes"
comments: true
---

## Precisamos falar sobre Testes

![Windows Error Screen](https://media.giphy.com/media/hv5AEBpH3ZyNoRnABG/giphy.gif)

Voc√™ certamente j√° viu essa imagem. Seja por ter usado um sistema Windows ou por ter visto um dos v√°rios memes que ela proporcionou. Como usu√°rio, n√£o h√° nada mais desagrad√°vel ao utilizar um sistema do que receber um erro como resposta. Pior ainda quando o erro acontece de maneira silenciosa. Muitos desses problemas poderiam ser evitados se a equipe de desenvolvimento utilizasse o TDD.

Mas o que √© isso afinal? De acordo com a [Wikipedia](https://pt.wikipedia.org/wiki/Test-driven_development) o TDD (ingl√™s: _Test Driven Developlement_ \| portugu√™s: Desenvolvimento Dirigido por Testes) √© _"uma t√©cnica de desenvolvimento de software que se relaciona com o conceito de verifica√ß√£o e valida√ß√£o e se baseia em um ciclo curto de repeti√ß√µes"_.

O conceito-chave aqui √© a **verifica√ß√£o e valida√ß√£o** do c√≥digo antes que o mesmo seja entregue ao cliente. A ideia central do TDD √© o _fail fast_, isto √©, se √© para existir um erro, √© melhor que o mesmo apare√ßa de imediato do que tarde a aparecer.

Mais do que isso, o TDD apresenta v√°rios benef√≠cios para a equipe de desenvolvimento. Imagine um c√≥digo (seu ou da sua equipe) que est√° parado h√° 2 anos. Agora voc√™ pretende implementar uma nova funcionalidade, ou talvez alterar alguma funcionalidade existente. Pode ser algo simples como implementar uma nova rota, adicionar um bot√£o, ou talvez algo mais complexo como alterar o sistema de pagamento.

A primeira coisa que voc√™ teria que fazer √© buscar a documenta√ß√£o do projeto para entender como ele funciona, verificar sua estrutura, a depend√™ncia dos elementos, etc. Em projetos bem documentados, isso n√£o levar√° muito tempo, mas via de regra, ser√° necess√°rio muito tempo e esfor√ßo para lembrar como o projeto foi estruturado.

Implementar uma nova funcionalidade sem compreender corretamente como o sistema est√° funcionando pode gerar _bugs_ ocultos que aparecer√£o apenas na hora mais inapropriada poss√≠vel, pois √© a lei de Murphy ainda impera sobre o mundo.

Mesmo uma boa documenta√ß√£o n√£o seria capaz de prever o que seria alterado ou afetado pelas mudan√ßas que voc√™ far√° no c√≥digo e, certamente, colocar erros ocultos em produ√ß√£o n√£o √© uma boa op√ß√£o. Fazer isso pode tanto custar horas de sono para a equipe de desenvolvimento quando milh√µes para as organiza√ß√µes.

√â por isso que o TDD, segue a filosofia do _fail fast_. Em um projeto guiado por testes, cada elemento foi devidamente testado, bem como suas rela√ß√µes, de forma que ao refatorar ou implementar algo novo, os testes informar√£o se tudo continua ou n√£o funcionando

Vamos a um exemplo simples utilizando a linguagem Python:

```python
class Calculator:
    def __init__(self, a):
        self.a = a
    
    def __add__(self, b):
        self.a += b
        return self.a
```

Nesse exemplo, criamos uma calculadora simples que recebe um valor inicial ao instanciar o objeto e que pode receber novos valores para serem somados. Ao somar um novo valor, o mesmo ser√° devolvido como resposta:

```python
calc = Calculator(2)
calc + 2
# >>> 4
```

Nada de surpreendente, n√£o √© mesmo? Mas e se somarmos um valor do tipo `float`, o que aconteceria?

```python
calc = Calculator(2)
calc + 2.0
# >>> 4.0
```

Hum, parece que nossa sa√≠da tamb√©m foi modificada. Se pensarmos em uma calculadora comum isso n√£o seria um problema, mas se a sa√≠da desse c√°lculo fosse utilizada como √≠ndice de um *array*, isso certamente seria um problema.

Poder√≠amos fazer o _casting_ na pr√≥pria classe, voc√™ diria. Assim garantir√≠amos que apenas ter√≠amos como retorno n√∫meros inteiros. Vejamos como ficaria:

```python
class Calculator:
    def __init__(self, a):
        self.a = a
    
    def __add__(self, b):
        self.a += b
        return int(self.a)

calc = Calculator(2)
calc + 2.0
# >>> 4
```

Nosso problema foi resolvido e nem precisamos "fazer testes" para isso. Calma jovem! O m√©todo `__add__` do Python permite mais do que fazer somas. Ele tamb√©m permite que listas sejam concatenadas. Agora imagine algu√©m sabendo dessa propriedade da linguagem e que acredite que o c√°lculo feito aqui √© com a soma de listas. Qual seria o resultado?

```python
calc = Calculator([2])
calc + [2]
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
#   File "<stdin>", line 7, in __add__
# TypeError: int() argument must be a string, a bytes-like object or a number, not 'list'
```

Voc√™ pode argumentar que isso √© um erro de quem utilizou a classe e n√£o de quem a escreveu. Ser√°? Onde na classe foi especificado qual deferia ser o padr√£o de entrada e qual seria o padr√£o de sa√≠da? Em nenhum lugar isso foi tradado. Por isso, Python recomenda o uso de _annotations_, veja:

```python
class Calculator:
    def __init__(self, a: int) -> None:
        self.a = a
    
    def __add__(self, b: int) -> int:
        self.a += b
        return int(self.a)
```

Bem mais leg√≠vel, n√£o acha? Mas e se quisermos dar super poderes para a nossa soma? E se ao inv√©s de apenas somarmos dois n√∫meros ela fa√ßa a soma com o fatorial de um n√∫mero? Ainda ter√≠amos inteiros como entrada e como sa√≠da.

```python
from math import factorial 

class Calculator:
    def __init__(self, a: int) -> None:
        self.a = a
    
    def __add__(self, b: int) -> int:
        self.a += factorial(b)
        return int(self.a)

calc = Calculator(2)
calc + 2
# >>> 4
```

Quem olhasse para essa classe e fizesse o teste com os n√∫meros `2` e `2` provavelmente n√£o notaria diferen√ßa alguma, e ao ver que o c√≥digo continua funcionando e retornando `4` e o item de √≠ndice 4 do *array* continua sendo exibido na tela. Com isso faria aquele _commit_ com um erro silencioso que logo iria estourar em produ√ß√£o.

Toda essa novela √© para mostrar que mesmo com uma classe simples e que tem apenas uma fun√ß√£o (somar dois n√∫meros), a falta de testes pode ocasionar problemas. O teste n√£o isenta o c√≥digo de ter coment√°rios, tipagem, anota√ß√µes ou qualquer outra coisa, pelo contr√°rio, ele complementa a compreens√£o, a seguran√ßa e a qualidade do c√≥digo.

## Duas mentalidades

Uma das melhores ilustra√ß√µes que j√° vi sobre o TDD √© a trazida por Harry Percival em seu livro "TDD com Python", onde o autor nos apresenta dois personagens dos testes o **Testing Goat** e o **Refactoring Cat**.

Segundo o autor, o Bode al√©m de ser o mascote n√£o oficial dos testes na comunidade Python, √© tamb√©m um grande mestre na cultura dos testes. Os caprinos podem alcan√ßar lugares inimagin√°veis em solos perigosos e complexos, podendo, inclusive subir em √°rvores, acredite.

![Goats on a Three](https://media.giphy.com/media/xTiTnvGtFzh6W5K1m8/giphy.gif)

Esses animais conseguem fazer isso, pois n√£o d√£o passos r√°pidos e auto-confiantes, mas sim porque testam cada passo antes de fazer. Testam a estabilidade da superf√≠cie, a for√ßa necess√°ria, a ader√™ncia... e s√≥ depois d√£o o passo final.

Em contrapartida, o autor apresenta o outro personagem o **Refactoring Cat**, aquele gato auto-confiante que conhece suas habilidades e sabe fazer saltos com total leveza e certeza. Calcula tudo em sua mente, n√£o teste nada e simplesmente parte para o abra√ßo.

![Cat falling into a bath](https://media.giphy.com/media/SVYrs1hU0SiAf1nw1n/giphy.gif)

O bode pode at√© levar um pouco mais de tempo para dar seu salto, mas qual dos dois chegou ao destino? Tenha isso em mente, o TDD n√£o se trata de fazer r√°pido, se trata de fazer certo e bem feito. √â como costumamos dizer: "fa√ßa bem feito e far√° uma √∫nica vez" (adeus _refactoring cat_).

## O Ciclo de Testes

O TDD √© um processo c√≠clico em que tudo come√ßa com... testes. O processo √© divido em tr√™s etapas:

- Escreva um teste que falha
- Fa√ßa o teste passar
- Refatore

> **Nota**: Esse ciclo tamb√©m √© conhecido como "vermelho (üìï), verde (üìó), refatora (üìò)".

A recomenda√ß√£o √© que os teste sejam cont√≠nuos e incrementais, ou seja, teste cada pequena funcionalidade antes de partir para a pr√≥xima. Assim, voc√™ ter√° garantia de que tudo est√° funcionando perfeitamente.

Os testes devem ter uma anatomia clara e organizada de forma a facilitar sua leitura e compreens√£o, sendo divididos em tr√™s partes:

- **Arrange** (organizar): nessa parte s√£o definidas as condi√ß√µes pr√©-existentes para o nosso teste. Por exemplo, um teste de login, √© necess√°rio que haja um usu√°rio, o mesmo seria criado aqui.
- **Act** (agir): nessa parte √© executada a a√ß√£o principal do teste. Por exemplo, no teste de login, aqui seria o momento em que o usu√°rio preenche seus dados e clica no bot√£o de logar.
- **Assert** (confirmar): nesta parte √© verificado o resultado do teste. Por exemplo, no caso do login, podemos verificar se o usu√°rio est√° realmente logado e se foi redirecionado para a tela correta.

Lembre-se os testes devem ser **cont√≠nuos e incrementais**, isso significa que, por padr√£o cada teste deve validar poucas coisas. Alguns recomendam, inclusive, que cada teste valide apenas uma coisa. No caso de login, do nosso exemplo, poder√≠amos ter os seguintes testes:

1. Usu√°rio tem o bot√£o de login para clicar
2. Usu√°rio clica no bot√£o de login e √© redirecionado para o formul√°rio
3. Usu√°rio envia o formul√°rio sem preencher os dados
4. Usu√°rio preenche com dados incorretos (email)
5. Usu√°rio preenche com dados incorretos (senha)
6. Usu√°rio preenche com dados corretos

Espere ai! Voc√™ est√° me dizendo que em um simples formul√°rio de login eu teria que escrever SEIS testes? N√£o! N√£o existe um n√∫mero correto ou incorreto de testes, mas o que existe √© a cobertura que estes testes ter√£o do seu c√≥digo e da sua funcionalidade. Cobrir um login com esses seis testes me garante que o usu√°rio pode executar a a√ß√£o, pode falhar ou ser bem sucedido.

Por isso, para escrever um bom teste, sempre √© recomendado pensar no que o seu sistema pretende fazer e como ser√° a intera√ß√£o com ele.

## Escrevendo um teste

Ent√£o, sem delongas, vamos ao nosso primeiro teste. Primeiro, vamos organizar nosso diret√≥rio com a seguinte estrutura:

```
root
‚îÇ 
‚îú‚îÄ src 
‚îÇ 
‚îî‚îÄ test 
   ‚îî‚îÄ test_calculator.py
```

> Estou utilizando a biblioteca `unittest` do Python, mas o mesmo conceito √© aplic√°vel √† _frameworks_ de teste e em outras linguagens.


```python
# test/test_calculator.py
# ---

from unittest import TestCase

class CalculatorTest(TestCase):

    def test_sum_two_numbers(self):
        # Arrange
        calc = Calculator(2)

        # Act
        calc + 3

        # Assert
        self.assertEqual(calc.total, 5)
```

Fizemos algumas coisas importantes aqui:

1. Importamos a nossa biblioteca de testes
2. Criamos uma classe de testes e herdamos de `TestCase`
3. Criamos nosso primeiro teste iniciando com a palavrra `test_`
4. Dividimos nosso teste nas tr√™s parte do *AAA*:
   1. Instanciamos a calculadora com um valor incial `2`. Veja que √© uma pr√©-condi√ß√£o que o c√°lculo seja realizado.
   2. Agimos sobre a inst√¢ncia da calculadora somando a ela outro valor.
   3. Confirmamos que o resultado da soma de `2` e `3` ser√° `5`

Note que ainda n√£o temos a classe `Calculator`, nem os seus m√©todos e atributos. Mas aqui j√° definimos muita coisa de como queremos que essa futura classe se comporte.

Ent√£o vamos come√ßar a rodar nosso ciclo de TDD. Ap√≥s escrevemos um teste, podemos execut√°-lo com `python -m unittest` obtendo a seguinte sa√≠da:

```
E
======================================================================
ERROR: test_sum_two_numbers (test.test_calculator.CalculatorTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/sanches/tdd/test/test_calculator.py", line 7, in test_sum_two_numbers
    calc = Calculator(2)
NameError: name 'Calculator' is not defined

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (errors=1)
```

Vamos analisar a resposta do teste de baixo para cima:

1. Vemos que houve uma falha (`FAILED`)
1. Um teste rodou em 0.001 segundos
1. Em `NameError` vemos que o nome `Calculator` n√£o foi definido
1. Acima vemos que ele foi utilizado quando tentamos instanciar nossa classe `Calculator`
1. Acima vemos em qual teste ocorreu, seu caminho e em qual linha
1. No come√ßo vemos um `E`, mostrando que houve um erro de apenas um teste (veremos mais logo adiante)

Tivemos sucesso na nossa primeira etapa do TDD. Criamos um teste que falha (üìï)!

Nossa pr√≥xima etapa √© escrever um pequeno peda√ßo de c√≥digo que fa√ßa o nosso c√≥digo passar. Ent√£o, vamos come√ßar a criar a nossa classse `Calculator`


```python
# src/calculator.py
# ---

class Calculator:
    pass
```

Vamos rodar novamente nosso teste e... hum, tivemos exatamente a mesma resposta apesar de termos criado a classe `Calculator`. Pois √©, nosso teste n√£o sabia de onde viria essa classe, nem n√≥s, mas agora podemos inform√°-lo sobre isso, portanto, adicione o seguinte na primeira linha do arquivo de teste: `from src.calculator import Calculator` e rode o teste novamente.

```
E
======================================================================
ERROR: test_sum_two_numbers (test.test_calculator.CalculatorTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/sanches/tdd/test/test_calculator.py", line 8, in test_sum_two_numbers
    calc = Calculator(2)
TypeError: Calculator() takes no arguments

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (errors=1)
```

Nosso errou mudou agora, isso quer dizer que nosso teste encontrou a classe `Calculator` e tentou instanciar um objeto, mas o que ocorreu? Tivemos um `TypeError` nos informando que passamos um argumento para a nossa classe, mas ela n√£o est√° preparada para isso. Isso significa que avan√ßamos mais um pouco em nosso teste. Vamos prosseguir:

Arquivo: _src/calculator.py_

```python
class Calculator:
    def __init__(self, value):
        pass
```

Ao rodar novamente o teste, tivemos uma mensagem diferente. Isso mostra que avan√ßamos mais ainda:

```
E
======================================================================
ERROR: test_sum_two_numbers (test.test_calculator.CalculatorTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/sanches/tdd/test/test_calculator.py", line 11, in test_sum_two_numbers
    calc + 3
TypeError: unsupported operand type(s) for +: 'Calculator' and 'int'

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (errors=1)
```

Nosso teste agora reclama que n√£o consegue somar um objeto do tipo `Calculator` com um objeto do tipo `int`. Isso significa que sa√≠mos da parte do `Arrange` e chegamos a parte do `Act` em nosso teste.

Vamos fazer mais uma altera√ß√£o:


```python
# src/calculator.py
# ---

class Calculator:
    def __init__(self, value):
        pass
    
    def __add__(self, number):
        pass
```

E rodar nosso teste:

```
E
======================================================================
ERROR: test_sum_two_numbers (test.test_calculator.CalculatorTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/sanches/tdd/test/test_calculator.py", line 14, in test_sum_two_numbers
    self.assertEqual(calc.total, 5)
AttributeError: 'Calculator' object has no attribute 'total'

----------------------------------------------------------------------
Ran 1 test in 0.011s

FAILED (errors=1)
```

Parece que n√£o temos um atributo chamado `total`. Vamos resolver isso:


```python
# src/calculator.py
# ---

class Calculator:
    def __init__(self, value):
        self.total = None
    
    def __add__(self, number):
        pass
```

E rodar nosso teste:

```
F
======================================================================
FAIL: test_sum_two_numbers (test.test_calculator.CalculatorTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/sanches/tdd/test/test_calculator.py", line 14, in test_sum_two_numbers
    self.assertEqual(calc.total, 5)
AssertionError: None != 5

----------------------------------------------------------------------
Ran 1 test in 0.038s

FAILED (failures=1)
```

Observe que nossa mensagem mudou, n√£o temos mais o `E` no come√ßo do log nem o `FAILED (errors=1)` ao fim. Isso ocorre porque anteriormente t√≠nhamos um erro de execu√ß√£o do nosso teste, n√£o havia a classe, as opera√ß√µes n√£o eram permitidas, etc. Agora temos de fato um teste falhando, pois estamos verificando o valor do `total` e obtivemos que `None != 5`. Ou seja, nosso total n√£o √© igual ao valor que esper√°vamos. Vamos resolver isso:


```python
# src/calculator.py
# ---

class Calculator:
    def __init__(self, value):
        self.total = 5
    
    def __add__(self, number):
        pass
```

Observe agora o resultado do nosso teste:

```
.
----------------------------------------------------------------------
Ran 1 test in 0.000s
```

Finalmente temos um teste que passa. _"Mas espere"_, voc√™ pode me dizer, _"essa classe √© rid√≠cula, passamos um valor fixo para ela!"_. Sim, conclu√≠mos a segunda etapa do ciclo do TDD, obtivemos o "verde" (üìó), agora iniciamos a pr√≥xima etapa: a refatora√ß√£o (üìò).


```python
# src/calculator.py
# ---

class Calculator:
    def __init__(self, value):
        self.total = value
    
    def __add__(self, number):
        pass
```

Novamente temos um erro, isso quer dizer que regredimos em nosso teste, pois agora temos que `2 != 5`, o que de fato, √© verdade. Vamos corrigir isso e novamente fazer o teste passar.


```python
# src/calculator.py
# ---

class Calculator:
    def __init__(self, value):
        self.total = value
    
    def __add__(self, number):
        self.total += number
```

E finalmente temos uma nova mensagem de sucesso. Isso j√° merece um _commit_, afinal criamos um teste, ele falhou, escrevemos nosso c√≥digo, fizemos ele passar e refatoramos. Seguimos o ciclo do TDD!

Ok, mas ser√° que algu√©m trabalha assim? Depende, h√° programadores que gostam de fazer teste com altera√ß√µes m√≠nimas e incrementais como fizemos aqui, h√° outros que preferem fazer um teste mais amplo e ent√£o escrever blocos de c√≥digo.

Contudo, para quem est√° come√ßando a usar o TDD, recomenda-se fortemente que fa√ßa os pequenos passos como fizemos aqui. Isso te ajudar√° a escrever testes melhores e organizar melhor o seu c√≥digo.

## Recomenda√ß√µes

Al√©m do TDD, existe o BDD (_Behavior Driven Development_), que ao inv√©s de focar em testes, foca em comportamento. Apesar de n√£o ser o foco aqui, o BDD trouxe um recurso interessante chamado `Gherkin`, uma linguagem que possui um conjunto de palavras-chave e estrutura para definir especifica√ß√µes execut√°veis.

Particularmente gosto de escrever um arquivo `Gherkin` antes de escrever meus testes, mesmo quando n√£o uso os testes do BDD. Fa√ßo isso, pois acredito que agrega valor aos testes uma vez que fica mais f√°cil e flu√≠do escreve-los posteriormente. Veja um exemplo:

```gherkin
Feature: create a simple calculator
    Scenario: sum two integer numbers
        Given I have a calculator class
        And I want to sum two numbers
        When I pass the values "2" and "3"
        Then I receive "5" as response
```

Veja que o texto escrito em `Gherkin` corresponde ao que fizemos em nosso teste. A vantagem aqui est√° na facilidade com que podemos escrever as especifica√ß√µes e cen√°rios em uma linguagem natural e sistematizada. Com isso, escrever os testes posteriormente se torna uma tarefa menos √°rdua.

## Refer√™ncias

- [Texto Wikipedia sobre TDD](https://en.wikipedia.org/wiki/Test-driven_development)
- [Lista de Frameworks de Teste por Linguagem](https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks)
- [Python Unittest](https://docs.python.org/3/library/unittest.html)
- [Sintaxe do Gherkin](https://cucumber.io/docs/gherkin/reference/)
